// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: composable/xcvm/v1beta1/ethereum.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ClientState struct {
	Inner *LightClientState `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	// Types that are valid to be assigned to XFrozenHeightRevisionHeight:
	//	*ClientState_FrozenHeightRevisionHeight
	XFrozenHeightRevisionHeight isClientState_XFrozenHeightRevisionHeight `protobuf_oneof:"_frozen_height_revision_height"`
	// Types that are valid to be assigned to XFrozenHeightRevisionNumber:
	//	*ClientState_FrozenHeightRevisionNumber
	XFrozenHeightRevisionNumber isClientState_XFrozenHeightRevisionNumber `protobuf_oneof:"_frozen_height_revision_number"`
	LatestHeight                uint64                                    `protobuf:"varint,4,opt,name=latest_height,json=latestHeight,proto3" json:"latest_height,omitempty"`
}

func (m *ClientState) Reset()         { *m = ClientState{} }
func (m *ClientState) String() string { return proto.CompactTextString(m) }
func (*ClientState) ProtoMessage()    {}
func (*ClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{0}
}
func (m *ClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientState.Merge(m, src)
}
func (m *ClientState) XXX_Size() int {
	return m.Size()
}
func (m *ClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientState.DiscardUnknown(m)
}

var xxx_messageInfo_ClientState proto.InternalMessageInfo

type isClientState_XFrozenHeightRevisionHeight interface {
	isClientState_XFrozenHeightRevisionHeight()
	MarshalTo([]byte) (int, error)
	Size() int
}
type isClientState_XFrozenHeightRevisionNumber interface {
	isClientState_XFrozenHeightRevisionNumber()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ClientState_FrozenHeightRevisionHeight struct {
	FrozenHeightRevisionHeight uint64 `protobuf:"varint,2,opt,name=frozen_height_revision_height,json=frozenHeightRevisionHeight,proto3,oneof" json:"frozen_height_revision_height,omitempty"`
}
type ClientState_FrozenHeightRevisionNumber struct {
	FrozenHeightRevisionNumber uint64 `protobuf:"varint,3,opt,name=frozen_height_revision_number,json=frozenHeightRevisionNumber,proto3,oneof" json:"frozen_height_revision_number,omitempty"`
}

func (*ClientState_FrozenHeightRevisionHeight) isClientState_XFrozenHeightRevisionHeight() {}
func (*ClientState_FrozenHeightRevisionNumber) isClientState_XFrozenHeightRevisionNumber() {}

func (m *ClientState) GetXFrozenHeightRevisionHeight() isClientState_XFrozenHeightRevisionHeight {
	if m != nil {
		return m.XFrozenHeightRevisionHeight
	}
	return nil
}
func (m *ClientState) GetXFrozenHeightRevisionNumber() isClientState_XFrozenHeightRevisionNumber {
	if m != nil {
		return m.XFrozenHeightRevisionNumber
	}
	return nil
}

func (m *ClientState) GetInner() *LightClientState {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *ClientState) GetFrozenHeightRevisionHeight() uint64 {
	if x, ok := m.GetXFrozenHeightRevisionHeight().(*ClientState_FrozenHeightRevisionHeight); ok {
		return x.FrozenHeightRevisionHeight
	}
	return 0
}

func (m *ClientState) GetFrozenHeightRevisionNumber() uint64 {
	if x, ok := m.GetXFrozenHeightRevisionNumber().(*ClientState_FrozenHeightRevisionNumber); ok {
		return x.FrozenHeightRevisionNumber
	}
	return 0
}

func (m *ClientState) GetLatestHeight() uint64 {
	if m != nil {
		return m.LatestHeight
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientState_FrozenHeightRevisionHeight)(nil),
		(*ClientState_FrozenHeightRevisionNumber)(nil),
	}
}

type SyncCommittee struct {
	PublicKeys         [][]byte `protobuf:"bytes,1,rep,name=public_keys,json=publicKeys,proto3" json:"public_keys,omitempty"`
	AggregatePublicKey []byte   `protobuf:"bytes,2,opt,name=aggregate_public_key,json=aggregatePublicKey,proto3" json:"aggregate_public_key,omitempty"`
}

func (m *SyncCommittee) Reset()         { *m = SyncCommittee{} }
func (m *SyncCommittee) String() string { return proto.CompactTextString(m) }
func (*SyncCommittee) ProtoMessage()    {}
func (*SyncCommittee) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{1}
}
func (m *SyncCommittee) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncCommittee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncCommittee.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncCommittee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncCommittee.Merge(m, src)
}
func (m *SyncCommittee) XXX_Size() int {
	return m.Size()
}
func (m *SyncCommittee) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncCommittee.DiscardUnknown(m)
}

var xxx_messageInfo_SyncCommittee proto.InternalMessageInfo

func (m *SyncCommittee) GetPublicKeys() [][]byte {
	if m != nil {
		return m.PublicKeys
	}
	return nil
}

func (m *SyncCommittee) GetAggregatePublicKey() []byte {
	if m != nil {
		return m.AggregatePublicKey
	}
	return nil
}

type LightClientState struct {
	FinalizedHeader      *BeaconBlockHeader `protobuf:"bytes,1,opt,name=finalized_header,json=finalizedHeader,proto3" json:"finalized_header,omitempty"`
	LatestFinalizedEpoch uint64             `protobuf:"varint,2,opt,name=latest_finalized_epoch,json=latestFinalizedEpoch,proto3" json:"latest_finalized_epoch,omitempty"`
	CurrentSyncCommittee *SyncCommittee     `protobuf:"bytes,3,opt,name=current_sync_committee,json=currentSyncCommittee,proto3" json:"current_sync_committee,omitempty"`
	NextSyncCommittee    *SyncCommittee     `protobuf:"bytes,4,opt,name=next_sync_committee,json=nextSyncCommittee,proto3" json:"next_sync_committee,omitempty"`
}

func (m *LightClientState) Reset()         { *m = LightClientState{} }
func (m *LightClientState) String() string { return proto.CompactTextString(m) }
func (*LightClientState) ProtoMessage()    {}
func (*LightClientState) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{2}
}
func (m *LightClientState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LightClientState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LightClientState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LightClientState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightClientState.Merge(m, src)
}
func (m *LightClientState) XXX_Size() int {
	return m.Size()
}
func (m *LightClientState) XXX_DiscardUnknown() {
	xxx_messageInfo_LightClientState.DiscardUnknown(m)
}

var xxx_messageInfo_LightClientState proto.InternalMessageInfo

func (m *LightClientState) GetFinalizedHeader() *BeaconBlockHeader {
	if m != nil {
		return m.FinalizedHeader
	}
	return nil
}

func (m *LightClientState) GetLatestFinalizedEpoch() uint64 {
	if m != nil {
		return m.LatestFinalizedEpoch
	}
	return 0
}

func (m *LightClientState) GetCurrentSyncCommittee() *SyncCommittee {
	if m != nil {
		return m.CurrentSyncCommittee
	}
	return nil
}

func (m *LightClientState) GetNextSyncCommittee() *SyncCommittee {
	if m != nil {
		return m.NextSyncCommittee
	}
	return nil
}

// A beacon block header is essentially a beacon block with only a reference to
// the beacon body as a 32 byte merkle tree root. This type of message is more
// lightweight than a full beacon block. The message does not contain
// a validator signature.
type BeaconBlockHeader struct {
	// Beacon chain slot that this block represents.
	Slot uint64 `protobuf:"varint,1,opt,name=slot,proto3" json:"slot,omitempty"`
	// Validator index of the validator that proposed the block header.
	ProposerIndex uint64 `protobuf:"varint,2,opt,name=proposer_index,json=proposerIndex,proto3" json:"proposer_index,omitempty"`
	// 32 byte merkle tree root of the parent ssz encoded block.
	ParentRoot []byte `protobuf:"bytes,3,opt,name=parent_root,json=parentRoot,proto3" json:"parent_root,omitempty"`
	// 32 byte merkle tree root of the resulting ssz encoded state after processing this block.
	StateRoot []byte `protobuf:"bytes,4,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	// 32 byte merkle tree root of the ssz encoded block body.
	BodyRoot []byte `protobuf:"bytes,5,opt,name=body_root,json=bodyRoot,proto3" json:"body_root,omitempty"`
}

func (m *BeaconBlockHeader) Reset()         { *m = BeaconBlockHeader{} }
func (m *BeaconBlockHeader) String() string { return proto.CompactTextString(m) }
func (*BeaconBlockHeader) ProtoMessage()    {}
func (*BeaconBlockHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{3}
}
func (m *BeaconBlockHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeaconBlockHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeaconBlockHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeaconBlockHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeaconBlockHeader.Merge(m, src)
}
func (m *BeaconBlockHeader) XXX_Size() int {
	return m.Size()
}
func (m *BeaconBlockHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BeaconBlockHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BeaconBlockHeader proto.InternalMessageInfo

func (m *BeaconBlockHeader) GetSlot() uint64 {
	if m != nil {
		return m.Slot
	}
	return 0
}

func (m *BeaconBlockHeader) GetProposerIndex() uint64 {
	if m != nil {
		return m.ProposerIndex
	}
	return 0
}

func (m *BeaconBlockHeader) GetParentRoot() []byte {
	if m != nil {
		return m.ParentRoot
	}
	return nil
}

func (m *BeaconBlockHeader) GetStateRoot() []byte {
	if m != nil {
		return m.StateRoot
	}
	return nil
}

func (m *BeaconBlockHeader) GetBodyRoot() []byte {
	if m != nil {
		return m.BodyRoot
	}
	return nil
}

type ReceiptProof struct {
	Proof map[string][]byte `protobuf:"bytes,1,rep,name=proof,proto3" json:"proof,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ReceiptProof) Reset()         { *m = ReceiptProof{} }
func (m *ReceiptProof) String() string { return proto.CompactTextString(m) }
func (*ReceiptProof) ProtoMessage()    {}
func (*ReceiptProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{4}
}
func (m *ReceiptProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiptProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiptProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiptProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiptProof.Merge(m, src)
}
func (m *ReceiptProof) XXX_Size() int {
	return m.Size()
}
func (m *ReceiptProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiptProof.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiptProof proto.InternalMessageInfo

func (m *ReceiptProof) GetProof() map[string][]byte {
	if m != nil {
		return m.Proof
	}
	return nil
}

type LightClientUpdate struct {
	AttestedHeader *BeaconBlockHeader `protobuf:"bytes,1,opt,name=attested_header,json=attestedHeader,proto3" json:"attested_header,omitempty"`
	// Types that are valid to be assigned to XSyncCommitteeUpdate:
	//
	//	*LightClientUpdate_SyncCommitteeUpdate
	XSyncCommitteeUpdate isLightClientUpdate_XSyncCommitteeUpdate `protobuf_oneof:"_sync_committee_update"`
	FinalizedHeader      *BeaconBlockHeader                       `protobuf:"bytes,3,opt,name=finalized_header,json=finalizedHeader,proto3" json:"finalized_header,omitempty"`
	ExecutionPayload     *ExecutionPayloadProof                   `protobuf:"bytes,4,opt,name=execution_payload,json=executionPayload,proto3" json:"execution_payload,omitempty"`
	FinalityProof        *FinalityProof                           `protobuf:"bytes,5,opt,name=finality_proof,json=finalityProof,proto3" json:"finality_proof,omitempty"`
	SyncAggregate        *SyncAggregate                           `protobuf:"bytes,6,opt,name=sync_aggregate,json=syncAggregate,proto3" json:"sync_aggregate,omitempty"`
	SignatureSlot        uint64                                   `protobuf:"varint,7,opt,name=signature_slot,json=signatureSlot,proto3" json:"signature_slot,omitempty"`
}

func (m *LightClientUpdate) Reset()         { *m = LightClientUpdate{} }
func (m *LightClientUpdate) String() string { return proto.CompactTextString(m) }
func (*LightClientUpdate) ProtoMessage()    {}
func (*LightClientUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{5}
}
func (m *LightClientUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LightClientUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LightClientUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LightClientUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightClientUpdate.Merge(m, src)
}
func (m *LightClientUpdate) XXX_Size() int {
	return m.Size()
}
func (m *LightClientUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_LightClientUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_LightClientUpdate proto.InternalMessageInfo

type isLightClientUpdate_XSyncCommitteeUpdate interface {
	isLightClientUpdate_XSyncCommitteeUpdate()
	MarshalTo([]byte) (int, error)
	Size() int
}

type LightClientUpdate_SyncCommitteeUpdate struct {
	SyncCommitteeUpdate *SyncCommitteeUpdate `protobuf:"bytes,2,opt,name=sync_committee_update,json=syncCommitteeUpdate,proto3,oneof" json:"sync_committee_update,omitempty"`
}

func (*LightClientUpdate_SyncCommitteeUpdate) isLightClientUpdate_XSyncCommitteeUpdate() {}

func (m *LightClientUpdate) GetXSyncCommitteeUpdate() isLightClientUpdate_XSyncCommitteeUpdate {
	if m != nil {
		return m.XSyncCommitteeUpdate
	}
	return nil
}

func (m *LightClientUpdate) GetAttestedHeader() *BeaconBlockHeader {
	if m != nil {
		return m.AttestedHeader
	}
	return nil
}

func (m *LightClientUpdate) GetSyncCommitteeUpdate() *SyncCommitteeUpdate {
	if x, ok := m.GetXSyncCommitteeUpdate().(*LightClientUpdate_SyncCommitteeUpdate); ok {
		return x.SyncCommitteeUpdate
	}
	return nil
}

func (m *LightClientUpdate) GetFinalizedHeader() *BeaconBlockHeader {
	if m != nil {
		return m.FinalizedHeader
	}
	return nil
}

func (m *LightClientUpdate) GetExecutionPayload() *ExecutionPayloadProof {
	if m != nil {
		return m.ExecutionPayload
	}
	return nil
}

func (m *LightClientUpdate) GetFinalityProof() *FinalityProof {
	if m != nil {
		return m.FinalityProof
	}
	return nil
}

func (m *LightClientUpdate) GetSyncAggregate() *SyncAggregate {
	if m != nil {
		return m.SyncAggregate
	}
	return nil
}

func (m *LightClientUpdate) GetSignatureSlot() uint64 {
	if m != nil {
		return m.SignatureSlot
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*LightClientUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*LightClientUpdate_SyncCommitteeUpdate)(nil),
	}
}

type SyncCommitteeUpdate struct {
	NextSyncCommittee       *SyncCommittee `protobuf:"bytes,1,opt,name=next_sync_committee,json=nextSyncCommittee,proto3" json:"next_sync_committee,omitempty"`
	NextSyncCommitteeBranch [][]byte       `protobuf:"bytes,2,rep,name=next_sync_committee_branch,json=nextSyncCommitteeBranch,proto3" json:"next_sync_committee_branch,omitempty"`
}

func (m *SyncCommitteeUpdate) Reset()         { *m = SyncCommitteeUpdate{} }
func (m *SyncCommitteeUpdate) String() string { return proto.CompactTextString(m) }
func (*SyncCommitteeUpdate) ProtoMessage()    {}
func (*SyncCommitteeUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{6}
}
func (m *SyncCommitteeUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncCommitteeUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncCommitteeUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncCommitteeUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncCommitteeUpdate.Merge(m, src)
}
func (m *SyncCommitteeUpdate) XXX_Size() int {
	return m.Size()
}
func (m *SyncCommitteeUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncCommitteeUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_SyncCommitteeUpdate proto.InternalMessageInfo

func (m *SyncCommitteeUpdate) GetNextSyncCommittee() *SyncCommittee {
	if m != nil {
		return m.NextSyncCommittee
	}
	return nil
}

func (m *SyncCommitteeUpdate) GetNextSyncCommitteeBranch() [][]byte {
	if m != nil {
		return m.NextSyncCommitteeBranch
	}
	return nil
}

type ExecutionPayloadProof struct {
	StateRoot              []byte   `protobuf:"bytes,1,opt,name=state_root,json=stateRoot,proto3" json:"state_root,omitempty"`
	BlockNumber            uint64   `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	MultiProof             [][]byte `protobuf:"bytes,3,rep,name=multi_proof,json=multiProof,proto3" json:"multi_proof,omitempty"`
	ExecutionPayloadBranch [][]byte `protobuf:"bytes,4,rep,name=execution_payload_branch,json=executionPayloadBranch,proto3" json:"execution_payload_branch,omitempty"`
	Timestamp              uint64   `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *ExecutionPayloadProof) Reset()         { *m = ExecutionPayloadProof{} }
func (m *ExecutionPayloadProof) String() string { return proto.CompactTextString(m) }
func (*ExecutionPayloadProof) ProtoMessage()    {}
func (*ExecutionPayloadProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{7}
}
func (m *ExecutionPayloadProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecutionPayloadProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecutionPayloadProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecutionPayloadProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecutionPayloadProof.Merge(m, src)
}
func (m *ExecutionPayloadProof) XXX_Size() int {
	return m.Size()
}
func (m *ExecutionPayloadProof) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecutionPayloadProof.DiscardUnknown(m)
}

var xxx_messageInfo_ExecutionPayloadProof proto.InternalMessageInfo

func (m *ExecutionPayloadProof) GetStateRoot() []byte {
	if m != nil {
		return m.StateRoot
	}
	return nil
}

func (m *ExecutionPayloadProof) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *ExecutionPayloadProof) GetMultiProof() [][]byte {
	if m != nil {
		return m.MultiProof
	}
	return nil
}

func (m *ExecutionPayloadProof) GetExecutionPayloadBranch() [][]byte {
	if m != nil {
		return m.ExecutionPayloadBranch
	}
	return nil
}

func (m *ExecutionPayloadProof) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type FinalityProof struct {
	Epoch          uint64   `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	FinalityBranch [][]byte `protobuf:"bytes,2,rep,name=finality_branch,json=finalityBranch,proto3" json:"finality_branch,omitempty"`
}

func (m *FinalityProof) Reset()         { *m = FinalityProof{} }
func (m *FinalityProof) String() string { return proto.CompactTextString(m) }
func (*FinalityProof) ProtoMessage()    {}
func (*FinalityProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{8}
}
func (m *FinalityProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinalityProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinalityProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinalityProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinalityProof.Merge(m, src)
}
func (m *FinalityProof) XXX_Size() int {
	return m.Size()
}
func (m *FinalityProof) XXX_DiscardUnknown() {
	xxx_messageInfo_FinalityProof.DiscardUnknown(m)
}

var xxx_messageInfo_FinalityProof proto.InternalMessageInfo

func (m *FinalityProof) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *FinalityProof) GetFinalityBranch() [][]byte {
	if m != nil {
		return m.FinalityBranch
	}
	return nil
}

type SyncAggregate struct {
	SyncCommitteeBits      []byte `protobuf:"bytes,1,opt,name=sync_committee_bits,json=syncCommitteeBits,proto3" json:"sync_committee_bits,omitempty"`
	SyncCommitteeSignature []byte `protobuf:"bytes,2,opt,name=sync_committee_signature,json=syncCommitteeSignature,proto3" json:"sync_committee_signature,omitempty"`
}

func (m *SyncAggregate) Reset()         { *m = SyncAggregate{} }
func (m *SyncAggregate) String() string { return proto.CompactTextString(m) }
func (*SyncAggregate) ProtoMessage()    {}
func (*SyncAggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f791ac38dedb0bb8, []int{9}
}
func (m *SyncAggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncAggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncAggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncAggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncAggregate.Merge(m, src)
}
func (m *SyncAggregate) XXX_Size() int {
	return m.Size()
}
func (m *SyncAggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncAggregate.DiscardUnknown(m)
}

var xxx_messageInfo_SyncAggregate proto.InternalMessageInfo

func (m *SyncAggregate) GetSyncCommitteeBits() []byte {
	if m != nil {
		return m.SyncCommitteeBits
	}
	return nil
}

func (m *SyncAggregate) GetSyncCommitteeSignature() []byte {
	if m != nil {
		return m.SyncCommitteeSignature
	}
	return nil
}

func init() {
	proto.RegisterType((*ClientState)(nil), "composable.xcvm.v1beta1.ClientState")
	proto.RegisterType((*SyncCommittee)(nil), "composable.xcvm.v1beta1.SyncCommittee")
	proto.RegisterType((*LightClientState)(nil), "composable.xcvm.v1beta1.LightClientState")
	proto.RegisterType((*BeaconBlockHeader)(nil), "composable.xcvm.v1beta1.BeaconBlockHeader")
	proto.RegisterType((*ReceiptProof)(nil), "composable.xcvm.v1beta1.ReceiptProof")
	proto.RegisterMapType((map[string][]byte)(nil), "composable.xcvm.v1beta1.ReceiptProof.ProofEntry")
	proto.RegisterType((*LightClientUpdate)(nil), "composable.xcvm.v1beta1.LightClientUpdate")
	proto.RegisterType((*SyncCommitteeUpdate)(nil), "composable.xcvm.v1beta1.SyncCommitteeUpdate")
	proto.RegisterType((*ExecutionPayloadProof)(nil), "composable.xcvm.v1beta1.ExecutionPayloadProof")
	proto.RegisterType((*FinalityProof)(nil), "composable.xcvm.v1beta1.FinalityProof")
	proto.RegisterType((*SyncAggregate)(nil), "composable.xcvm.v1beta1.SyncAggregate")
}

func init() {
	proto.RegisterFile("composable/xcvm/v1beta1/ethereum.proto", fileDescriptor_f791ac38dedb0bb8)
}

var fileDescriptor_f791ac38dedb0bb8 = []byte{
	// 972 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xae, 0x9b, 0x64, 0xa1, 0x27, 0x49, 0xdb, 0x4c, 0xb3, 0xd9, 0x10, 0xd8, 0x6c, 0x09, 0xa2,
	0x14, 0x84, 0x92, 0xdd, 0xc2, 0x45, 0x05, 0x17, 0x88, 0xac, 0x5a, 0x15, 0x01, 0xab, 0x6a, 0xa2,
	0xe5, 0x02, 0x90, 0x2c, 0xdb, 0x39, 0x49, 0xac, 0xb5, 0x3d, 0x96, 0x67, 0x5c, 0xc5, 0xfb, 0x04,
	0x5c, 0xee, 0x73, 0xc0, 0x83, 0xc0, 0xe5, 0x0a, 0x09, 0x89, 0x4b, 0xd4, 0xbe, 0x08, 0x9a, 0x19,
	0xdb, 0xf9, 0x2f, 0x8b, 0x7a, 0x13, 0x79, 0xbe, 0xf3, 0xe3, 0x93, 0xef, 0x7c, 0xe7, 0x8c, 0xe1,
	0xc8, 0x61, 0x7e, 0xc8, 0xb8, 0x65, 0x7b, 0xd8, 0x9b, 0x3a, 0x57, 0x7e, 0xef, 0xea, 0x89, 0x8d,
	0xc2, 0x7a, 0xd2, 0x43, 0x31, 0xc1, 0x08, 0x63, 0xbf, 0x1b, 0x46, 0x4c, 0x30, 0xf2, 0x60, 0xe6,
	0xd7, 0x95, 0x7e, 0xdd, 0xd4, 0xaf, 0xf5, 0x8e, 0xc3, 0xb8, 0xcf, 0xb8, 0xa9, 0xdc, 0x7a, 0xfa,
	0xa0, 0x63, 0x5a, 0xf5, 0x31, 0x1b, 0x33, 0x8d, 0xcb, 0xa7, 0x14, 0x7d, 0x34, 0x66, 0x6c, 0xec,
	0x61, 0x4f, 0x9d, 0xec, 0x78, 0xd4, 0x13, 0xae, 0x8f, 0x5c, 0x58, 0x7e, 0xa8, 0x1d, 0x3a, 0xbf,
	0x6f, 0x43, 0xf9, 0xa9, 0xe7, 0x62, 0x20, 0x06, 0xc2, 0x12, 0x48, 0xbe, 0x82, 0x92, 0x1b, 0x04,
	0x18, 0x35, 0x8d, 0x43, 0xe3, 0xb8, 0x7c, 0xf2, 0x71, 0x77, 0x43, 0x29, 0xdd, 0xef, 0xdc, 0xf1,
	0x44, 0xcc, 0x45, 0x52, 0x1d, 0x47, 0xce, 0xe1, 0xe1, 0x28, 0x62, 0x2f, 0x31, 0x30, 0x27, 0x28,
	0x5d, 0xcc, 0x08, 0xaf, 0x5c, 0xee, 0xb2, 0xec, 0xdc, 0xdc, 0x3e, 0x34, 0x8e, 0x8b, 0x17, 0x5b,
	0xb4, 0xa5, 0xdd, 0x2e, 0x14, 0x4a, 0x53, 0x27, 0x7d, 0xfa, 0xc5, 0x30, 0x6e, 0xc9, 0x13, 0xc4,
	0xbe, 0x8d, 0x51, 0xb3, 0xa0, 0xf2, 0x18, 0xeb, 0xf3, 0x3c, 0x53, 0x3e, 0x32, 0xcf, 0x07, 0x50,
	0xf5, 0x2c, 0x81, 0x5c, 0x64, 0xef, 0x2f, 0xca, 0x38, 0x5a, 0xd1, 0xa0, 0x8e, 0xea, 0x1f, 0x42,
	0xdb, 0xbc, 0xb5, 0xea, 0xdb, 0x3c, 0x74, 0x3d, 0x1d, 0x1b, 0xaa, 0x83, 0x24, 0x70, 0x9e, 0x32,
	0xdf, 0x77, 0x85, 0x40, 0x24, 0x8f, 0xa0, 0x1c, 0xc6, 0xb6, 0xe7, 0x3a, 0xe6, 0x0b, 0x4c, 0x78,
	0xd3, 0x38, 0x2c, 0x1c, 0x57, 0x28, 0x68, 0xe8, 0x5b, 0x4c, 0x38, 0x79, 0x0c, 0x75, 0x6b, 0x3c,
	0x8e, 0x70, 0x6c, 0x09, 0x34, 0x67, 0xae, 0x8a, 0xa1, 0x0a, 0x25, 0xb9, 0xed, 0x32, 0x0b, 0xe9,
	0xfc, 0xb5, 0x0d, 0xfb, 0xcb, 0xc4, 0x93, 0xe7, 0xb0, 0x3f, 0x72, 0x03, 0xcb, 0x73, 0x5f, 0xe2,
	0xd0, 0x9c, 0xa0, 0x35, 0xcc, 0xbb, 0xf7, 0xc9, 0xc6, 0xee, 0xf5, 0xd1, 0x72, 0x58, 0xd0, 0xf7,
	0x98, 0xf3, 0xe2, 0x42, 0x45, 0xd0, 0xbd, 0x3c, 0x87, 0x06, 0xc8, 0xe7, 0xd0, 0x48, 0x89, 0x9b,
	0x65, 0xc7, 0x90, 0x39, 0x13, 0xdd, 0x41, 0x5a, 0xd7, 0xd6, 0xf3, 0xcc, 0x78, 0x26, 0x6d, 0xe4,
	0x67, 0x68, 0x38, 0x71, 0x14, 0x61, 0x20, 0x4c, 0x9e, 0x04, 0x8e, 0xe9, 0x64, 0x74, 0xa8, 0x7e,
	0x95, 0x4f, 0x8e, 0x36, 0x96, 0xb4, 0x40, 0x1e, 0xad, 0xa7, 0x59, 0x16, 0x29, 0xfd, 0x01, 0x0e,
	0x02, 0x9c, 0xae, 0xa4, 0x2e, 0xfe, 0xaf, 0xd4, 0x35, 0x99, 0x62, 0x01, 0xea, 0xfc, 0x66, 0x40,
	0x6d, 0x85, 0x12, 0x42, 0xa0, 0xc8, 0x3d, 0x26, 0x14, 0x99, 0x45, 0xaa, 0x9e, 0xc9, 0x87, 0xb0,
	0x1b, 0x46, 0x2c, 0x64, 0x1c, 0x23, 0xd3, 0x0d, 0x86, 0x38, 0x4d, 0xd9, 0xa8, 0x66, 0xe8, 0x37,
	0x12, 0x54, 0xbd, 0xb7, 0x14, 0x0b, 0x11, 0x63, 0x42, 0xfd, 0x77, 0xd9, 0x7b, 0x05, 0x51, 0xc6,
	0x04, 0x79, 0x08, 0xc0, 0x65, 0xf7, 0xb4, 0xbd, 0xa8, 0xec, 0x3b, 0x0a, 0x51, 0xe6, 0x77, 0x61,
	0xc7, 0x66, 0xc3, 0x44, 0x5b, 0x4b, 0xca, 0xfa, 0xb6, 0x04, 0xa4, 0xb1, 0xf3, 0xca, 0x80, 0x0a,
	0x45, 0x07, 0xdd, 0x50, 0x5c, 0x46, 0x8c, 0x8d, 0xc8, 0x39, 0x94, 0x42, 0xf9, 0xa0, 0x34, 0x56,
	0x3e, 0x79, 0xbc, 0x91, 0x88, 0xf9, 0xa8, 0xae, 0xfa, 0x3d, 0x0b, 0x44, 0x94, 0x50, 0x1d, 0xde,
	0x3a, 0x05, 0x98, 0x81, 0x64, 0x1f, 0x0a, 0x52, 0x8d, 0xf2, 0xdf, 0xef, 0x50, 0xf9, 0x48, 0xea,
	0x50, 0xba, 0xb2, 0xbc, 0x18, 0x53, 0x85, 0xea, 0xc3, 0x17, 0xdb, 0xa7, 0x46, 0xe7, 0xba, 0x08,
	0xb5, 0x39, 0x61, 0x3e, 0x0f, 0x87, 0x52, 0x99, 0x03, 0xd8, 0xb3, 0x84, 0x14, 0xc9, 0x5d, 0x84,
	0xb9, 0x9b, 0xa5, 0x48, 0xbb, 0x82, 0x70, 0x7f, 0xb1, 0xfd, 0x66, 0xac, 0xde, 0xa6, 0x8a, 0x2a,
	0x9f, 0x7c, 0xfa, 0x66, 0x2a, 0xd0, 0x15, 0x5e, 0x6c, 0xd1, 0x03, 0xbe, 0x0a, 0xcb, 0xbd, 0xb1,
	0x6e, 0xaa, 0x0a, 0x77, 0x9f, 0xaa, 0x9f, 0xa0, 0x86, 0x53, 0x74, 0x62, 0x21, 0x37, 0x47, 0x68,
	0x25, 0x1e, 0xb3, 0x86, 0xa9, 0x7e, 0xbb, 0x1b, 0xf3, 0x9e, 0x65, 0x11, 0x97, 0x3a, 0x40, 0x35,
	0x89, 0xee, 0xe3, 0x12, 0x4c, 0xbe, 0x87, 0x5d, 0xfd, 0x3e, 0x91, 0x98, 0x5a, 0x10, 0xa5, 0xff,
	0x98, 0x8c, 0xf3, 0xd4, 0x5d, 0x67, 0xac, 0x8e, 0xe6, 0x8f, 0x32, 0x9d, 0x62, 0x3a, 0x5f, 0x44,
	0xcd, 0x7b, 0x6f, 0x30, 0x68, 0x5f, 0x67, 0xde, 0xb4, 0xca, 0xe7, 0x8f, 0x72, 0x74, 0xb8, 0x3b,
	0x0e, 0x2c, 0x11, 0x47, 0x68, 0xaa, 0xc1, 0x7a, 0x4b, 0x8f, 0x4e, 0x8e, 0x0e, 0x3c, 0x26, 0xfa,
	0x4d, 0x68, 0x98, 0x6b, 0x1b, 0xdc, 0xf9, 0xd5, 0x80, 0x83, 0x35, 0x4d, 0xdc, 0xb4, 0x15, 0x8c,
	0x3b, 0x6e, 0x05, 0xf2, 0x25, 0xb4, 0xd6, 0xe4, 0x35, 0xed, 0xc8, 0x0a, 0xd4, 0x16, 0x94, 0xfb,
	0xfc, 0xc1, 0x4a, 0x58, 0x5f, 0x99, 0x3b, 0x7f, 0x1a, 0x70, 0x7f, 0x6d, 0xdf, 0x96, 0x46, 0xdf,
	0x58, 0x1e, 0xfd, 0xf7, 0xa1, 0x62, 0x4b, 0x05, 0x65, 0xf7, 0x9c, 0xde, 0x2f, 0x65, 0x85, 0xe9,
	0x6b, 0x4d, 0x6e, 0x17, 0x3f, 0xf6, 0x84, 0x9b, 0x36, 0xb9, 0xa0, 0x6f, 0x16, 0x05, 0xe9, 0x57,
	0x9c, 0x42, 0x73, 0x45, 0x65, 0x59, 0xdd, 0x45, 0xe5, 0xdd, 0x58, 0x16, 0x8f, 0x2e, 0x9b, 0xbc,
	0x07, 0x3b, 0xf9, 0x27, 0x82, 0x52, 0x4f, 0x91, 0xce, 0x80, 0xce, 0x33, 0xa8, 0x2e, 0x28, 0x46,
	0x6e, 0x04, 0x7d, 0x27, 0xe8, 0x1d, 0xa9, 0x0f, 0xe4, 0x23, 0xd8, 0xcb, 0x75, 0xb8, 0xc0, 0x56,
	0x2e, 0xcf, 0x94, 0xa4, 0x44, 0xdf, 0x99, 0x33, 0x8d, 0x74, 0xe1, 0x60, 0x99, 0x6d, 0x57, 0xf0,
	0x94, 0xa4, 0xda, 0xc2, 0xa8, 0xf6, 0x5d, 0xc1, 0xe5, 0x1f, 0x5d, 0xf2, 0xcf, 0xc5, 0x94, 0x2e,
	0xa9, 0xc6, 0x42, 0xd0, 0x20, 0xb3, 0xf6, 0x8f, 0xfe, 0xb8, 0x6e, 0x1b, 0xaf, 0xaf, 0xdb, 0xc6,
	0x3f, 0xd7, 0x6d, 0xe3, 0xd5, 0x4d, 0x7b, 0xeb, 0xf5, 0x4d, 0x7b, 0xeb, 0xef, 0x9b, 0xf6, 0xd6,
	0x8f, 0x95, 0xa9, 0xfe, 0x38, 0x13, 0x49, 0x88, 0xdc, 0xbe, 0xa7, 0xbe, 0x93, 0x3e, 0xfb, 0x37,
	0x00, 0x00, 0xff, 0xff, 0x1a, 0xd7, 0x11, 0x38, 0xbc, 0x09, 0x00, 0x00,
}

func (m *ClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LatestHeight != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.LatestHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.XFrozenHeightRevisionNumber != nil {
		{
			size := m.XFrozenHeightRevisionNumber.Size()
			i -= size
			if _, err := m.XFrozenHeightRevisionNumber.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.XFrozenHeightRevisionHeight != nil {
		{
			size := m.XFrozenHeightRevisionHeight.Size()
			i -= size
			if _, err := m.XFrozenHeightRevisionHeight.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientState_FrozenHeightRevisionHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState_FrozenHeightRevisionHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEthereum(dAtA, i, uint64(m.FrozenHeightRevisionHeight))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ClientState_FrozenHeightRevisionNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientState_FrozenHeightRevisionNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintEthereum(dAtA, i, uint64(m.FrozenHeightRevisionNumber))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *SyncCommittee) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncCommittee) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncCommittee) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AggregatePublicKey) > 0 {
		i -= len(m.AggregatePublicKey)
		copy(dAtA[i:], m.AggregatePublicKey)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.AggregatePublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicKeys) > 0 {
		for iNdEx := len(m.PublicKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PublicKeys[iNdEx])
			copy(dAtA[i:], m.PublicKeys[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.PublicKeys[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LightClientState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LightClientState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LightClientState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextSyncCommittee != nil {
		{
			size, err := m.NextSyncCommittee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CurrentSyncCommittee != nil {
		{
			size, err := m.CurrentSyncCommittee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LatestFinalizedEpoch != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.LatestFinalizedEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.FinalizedHeader != nil {
		{
			size, err := m.FinalizedHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeaconBlockHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeaconBlockHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeaconBlockHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BodyRoot) > 0 {
		i -= len(m.BodyRoot)
		copy(dAtA[i:], m.BodyRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.BodyRoot)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParentRoot) > 0 {
		i -= len(m.ParentRoot)
		copy(dAtA[i:], m.ParentRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.ParentRoot)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposerIndex != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.ProposerIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Slot != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReceiptProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiptProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiptProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proof) > 0 {
		for k := range m.Proof {
			v := m.Proof[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintEthereum(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintEthereum(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintEthereum(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LightClientUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LightClientUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LightClientUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignatureSlot != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.SignatureSlot))
		i--
		dAtA[i] = 0x38
	}
	if m.SyncAggregate != nil {
		{
			size, err := m.SyncAggregate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.FinalityProof != nil {
		{
			size, err := m.FinalityProof.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ExecutionPayload != nil {
		{
			size, err := m.ExecutionPayload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.FinalizedHeader != nil {
		{
			size, err := m.FinalizedHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.XSyncCommitteeUpdate != nil {
		{
			size := m.XSyncCommitteeUpdate.Size()
			i -= size
			if _, err := m.XSyncCommitteeUpdate.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.AttestedHeader != nil {
		{
			size, err := m.AttestedHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LightClientUpdate_SyncCommitteeUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LightClientUpdate_SyncCommitteeUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SyncCommitteeUpdate != nil {
		{
			size, err := m.SyncCommitteeUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SyncCommitteeUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncCommitteeUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncCommitteeUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextSyncCommitteeBranch) > 0 {
		for iNdEx := len(m.NextSyncCommitteeBranch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NextSyncCommitteeBranch[iNdEx])
			copy(dAtA[i:], m.NextSyncCommitteeBranch[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.NextSyncCommitteeBranch[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.NextSyncCommittee != nil {
		{
			size, err := m.NextSyncCommittee.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEthereum(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecutionPayloadProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecutionPayloadProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecutionPayloadProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ExecutionPayloadBranch) > 0 {
		for iNdEx := len(m.ExecutionPayloadBranch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExecutionPayloadBranch[iNdEx])
			copy(dAtA[i:], m.ExecutionPayloadBranch[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.ExecutionPayloadBranch[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MultiProof) > 0 {
		for iNdEx := len(m.MultiProof) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MultiProof[iNdEx])
			copy(dAtA[i:], m.MultiProof[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.MultiProof[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BlockNumber != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.StateRoot) > 0 {
		i -= len(m.StateRoot)
		copy(dAtA[i:], m.StateRoot)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.StateRoot)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinalityProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinalityProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinalityProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FinalityBranch) > 0 {
		for iNdEx := len(m.FinalityBranch) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FinalityBranch[iNdEx])
			copy(dAtA[i:], m.FinalityBranch[iNdEx])
			i = encodeVarintEthereum(dAtA, i, uint64(len(m.FinalityBranch[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Epoch != 0 {
		i = encodeVarintEthereum(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncAggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncAggregate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncAggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SyncCommitteeSignature) > 0 {
		i -= len(m.SyncCommitteeSignature)
		copy(dAtA[i:], m.SyncCommitteeSignature)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.SyncCommitteeSignature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SyncCommitteeBits) > 0 {
		i -= len(m.SyncCommitteeBits)
		copy(dAtA[i:], m.SyncCommitteeBits)
		i = encodeVarintEthereum(dAtA, i, uint64(len(m.SyncCommitteeBits)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEthereum(dAtA []byte, offset int, v uint64) int {
	offset -= sovEthereum(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XFrozenHeightRevisionHeight != nil {
		n += m.XFrozenHeightRevisionHeight.Size()
	}
	if m.XFrozenHeightRevisionNumber != nil {
		n += m.XFrozenHeightRevisionNumber.Size()
	}
	if m.LatestHeight != 0 {
		n += 1 + sovEthereum(uint64(m.LatestHeight))
	}
	return n
}

func (m *ClientState_FrozenHeightRevisionHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEthereum(uint64(m.FrozenHeightRevisionHeight))
	return n
}
func (m *ClientState_FrozenHeightRevisionNumber) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovEthereum(uint64(m.FrozenHeightRevisionNumber))
	return n
}
func (m *SyncCommittee) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PublicKeys) > 0 {
		for _, b := range m.PublicKeys {
			l = len(b)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	l = len(m.AggregatePublicKey)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	return n
}

func (m *LightClientState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FinalizedHeader != nil {
		l = m.FinalizedHeader.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.LatestFinalizedEpoch != 0 {
		n += 1 + sovEthereum(uint64(m.LatestFinalizedEpoch))
	}
	if m.CurrentSyncCommittee != nil {
		l = m.CurrentSyncCommittee.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.NextSyncCommittee != nil {
		l = m.NextSyncCommittee.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	return n
}

func (m *BeaconBlockHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Slot != 0 {
		n += 1 + sovEthereum(uint64(m.Slot))
	}
	if m.ProposerIndex != 0 {
		n += 1 + sovEthereum(uint64(m.ProposerIndex))
	}
	l = len(m.ParentRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.BodyRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	return n
}

func (m *ReceiptProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Proof) > 0 {
		for k, v := range m.Proof {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovEthereum(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovEthereum(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovEthereum(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *LightClientUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestedHeader != nil {
		l = m.AttestedHeader.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.XSyncCommitteeUpdate != nil {
		n += m.XSyncCommitteeUpdate.Size()
	}
	if m.FinalizedHeader != nil {
		l = m.FinalizedHeader.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.ExecutionPayload != nil {
		l = m.ExecutionPayload.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.FinalityProof != nil {
		l = m.FinalityProof.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.SyncAggregate != nil {
		l = m.SyncAggregate.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.SignatureSlot != 0 {
		n += 1 + sovEthereum(uint64(m.SignatureSlot))
	}
	return n
}

func (m *LightClientUpdate_SyncCommitteeUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SyncCommitteeUpdate != nil {
		l = m.SyncCommitteeUpdate.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	return n
}
func (m *SyncCommitteeUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NextSyncCommittee != nil {
		l = m.NextSyncCommittee.Size()
		n += 1 + l + sovEthereum(uint64(l))
	}
	if len(m.NextSyncCommitteeBranch) > 0 {
		for _, b := range m.NextSyncCommitteeBranch {
			l = len(b)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	return n
}

func (m *ExecutionPayloadProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.StateRoot)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovEthereum(uint64(m.BlockNumber))
	}
	if len(m.MultiProof) > 0 {
		for _, b := range m.MultiProof {
			l = len(b)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	if len(m.ExecutionPayloadBranch) > 0 {
		for _, b := range m.ExecutionPayloadBranch {
			l = len(b)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	if m.Timestamp != 0 {
		n += 1 + sovEthereum(uint64(m.Timestamp))
	}
	return n
}

func (m *FinalityProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovEthereum(uint64(m.Epoch))
	}
	if len(m.FinalityBranch) > 0 {
		for _, b := range m.FinalityBranch {
			l = len(b)
			n += 1 + l + sovEthereum(uint64(l))
		}
	}
	return n
}

func (m *SyncAggregate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SyncCommitteeBits)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	l = len(m.SyncCommitteeSignature)
	if l > 0 {
		n += 1 + l + sovEthereum(uint64(l))
	}
	return n
}

func sovEthereum(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEthereum(x uint64) (n int) {
	return sovEthereum(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &LightClientState{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeightRevisionHeight", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFrozenHeightRevisionHeight = &ClientState_FrozenHeightRevisionHeight{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrozenHeightRevisionNumber", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XFrozenHeightRevisionNumber = &ClientState_FrozenHeightRevisionNumber{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestHeight", wireType)
			}
			m.LatestHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncCommittee) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncCommittee: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncCommittee: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeys = append(m.PublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.PublicKeys[len(m.PublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregatePublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregatePublicKey = append(m.AggregatePublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AggregatePublicKey == nil {
				m.AggregatePublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LightClientState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightClientState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightClientState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizedHeader == nil {
				m.FinalizedHeader = &BeaconBlockHeader{}
			}
			if err := m.FinalizedHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestFinalizedEpoch", wireType)
			}
			m.LatestFinalizedEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestFinalizedEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentSyncCommittee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CurrentSyncCommittee == nil {
				m.CurrentSyncCommittee = &SyncCommittee{}
			}
			if err := m.CurrentSyncCommittee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSyncCommittee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextSyncCommittee == nil {
				m.NextSyncCommittee = &SyncCommittee{}
			}
			if err := m.NextSyncCommittee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeaconBlockHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeaconBlockHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeaconBlockHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerIndex", wireType)
			}
			m.ProposerIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentRoot = append(m.ParentRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentRoot == nil {
				m.ParentRoot = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyRoot = append(m.BodyRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyRoot == nil {
				m.BodyRoot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiptProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiptProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiptProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Proof == nil {
				m.Proof = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowEthereum
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEthereum
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthEthereum
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthEthereum
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowEthereum
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthEthereum
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthEthereum
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipEthereum(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthEthereum
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Proof[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LightClientUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LightClientUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LightClientUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestedHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AttestedHeader == nil {
				m.AttestedHeader = &BeaconBlockHeader{}
			}
			if err := m.AttestedHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCommitteeUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncCommitteeUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.XSyncCommitteeUpdate = &LightClientUpdate_SyncCommitteeUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizedHeader == nil {
				m.FinalizedHeader = &BeaconBlockHeader{}
			}
			if err := m.FinalizedHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionPayload == nil {
				m.ExecutionPayload = &ExecutionPayloadProof{}
			}
			if err := m.ExecutionPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalityProof", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalityProof == nil {
				m.FinalityProof = &FinalityProof{}
			}
			if err := m.FinalityProof.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncAggregate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncAggregate == nil {
				m.SyncAggregate = &SyncAggregate{}
			}
			if err := m.SyncAggregate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureSlot", wireType)
			}
			m.SignatureSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureSlot |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncCommitteeUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncCommitteeUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncCommitteeUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSyncCommittee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextSyncCommittee == nil {
				m.NextSyncCommittee = &SyncCommittee{}
			}
			if err := m.NextSyncCommittee.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSyncCommitteeBranch", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextSyncCommitteeBranch = append(m.NextSyncCommitteeBranch, make([]byte, postIndex-iNdEx))
			copy(m.NextSyncCommitteeBranch[len(m.NextSyncCommitteeBranch)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecutionPayloadProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecutionPayloadProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecutionPayloadProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateRoot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateRoot = append(m.StateRoot[:0], dAtA[iNdEx:postIndex]...)
			if m.StateRoot == nil {
				m.StateRoot = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiProof", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultiProof = append(m.MultiProof, make([]byte, postIndex-iNdEx))
			copy(m.MultiProof[len(m.MultiProof)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionPayloadBranch", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionPayloadBranch = append(m.ExecutionPayloadBranch, make([]byte, postIndex-iNdEx))
			copy(m.ExecutionPayloadBranch[len(m.ExecutionPayloadBranch)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinalityProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinalityProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinalityProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalityBranch", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FinalityBranch = append(m.FinalityBranch, make([]byte, postIndex-iNdEx))
			copy(m.FinalityBranch[len(m.FinalityBranch)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncAggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncAggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncAggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCommitteeBits", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncCommitteeBits = append(m.SyncCommitteeBits[:0], dAtA[iNdEx:postIndex]...)
			if m.SyncCommitteeBits == nil {
				m.SyncCommitteeBits = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncCommitteeSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEthereum
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEthereum
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SyncCommitteeSignature = append(m.SyncCommitteeSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.SyncCommitteeSignature == nil {
				m.SyncCommitteeSignature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEthereum(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEthereum
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEthereum(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEthereum
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEthereum
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEthereum
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEthereum
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEthereum
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEthereum        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEthereum          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEthereum = fmt.Errorf("proto: unexpected end of group")
)
